{"version":3,"sources":["webpack:///./examples/simple.js","webpack:///./index.js","webpack:///./src/index.js","webpack:///./src/Picker.jsx","webpack:///./src/Animate.js"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAsC,uCAAuC,kBAAkB;;AAE/F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA,QAAO,SAAS,yCAAyC,EAAE;AAC3D;AACA;AACA,UAAS,yBAAyB;AAClC;AACA;AACA;AACA;AACA,UAAS,gEAAgE;AACzE;AACA;AACA;AACA;AACA,EAAC;;AAED,wH;;;;;;;ACzEA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA,uCAAsC,uCAAuC,kBAAkB;;AAE/F,uCAAsC;;AAEtC,qC;;;;;;;ACdA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED,uCAAsC,uCAAuC,kBAAkB;;AAE/F,qC;;;;;;;ACjBA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA;;AAEA,uCAAsC,uCAAuC,kBAAkB;;AAE/F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA,2CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,yDAAyD;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO,wEAAwE;AAC/E,gDAA+C,sDAAsD;AACrG,gDAA+C,kFAAkF;AACjI;AACA;AACA,UAAS,4EAA4E;AACrF;AACA;AACA;AACA;AACA,EAAC;AACD;AACA,qC;;;;;;;AClhBA;;AAEA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E","file":"simple.js","sourcesContent":["'use strict';\n\nrequire('rmc-picker/assets/index.less');\n\nvar _rmcPicker = require('rmc-picker');\n\nvar _rmcPicker2 = _interopRequireDefault(_rmcPicker);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/* eslint no-console:0 */\n\nvar count = 0;\nvar len = 10;\n\nvar Test = _react2[\"default\"].createClass({\n  displayName: 'Test',\n  getInitialState: function getInitialState() {\n    return {\n      items: this.getItems(count),\n      value: '' + count\n    };\n  },\n  onChange: function onChange(value) {\n    console.log('onChange', value);\n    this.setState({\n      value: value\n    });\n  },\n  getItems: function getItems(start) {\n    var items = [];\n    for (var i = start; i < start + len; i++) {\n      items.push({\n        value: String(i),\n        label: count + ' ' + i\n      });\n    }\n    return items;\n  },\n  rerender: function rerender() {\n    count += len;\n    var items = this.getItems(count);\n    this.setState({\n      items: items,\n      value: String(count)\n    });\n  },\n  render: function render() {\n    return _react2[\"default\"].createElement(\n      'div',\n      { style: { border: '1px solid black', padding: 10 } },\n      _react2[\"default\"].createElement(\n        'button',\n        { onClick: this.rerender },\n        'rerender'\n      ),\n      _react2[\"default\"].createElement(\n        _rmcPicker2[\"default\"],\n        { selectedValue: this.state.value, onValueChange: this.onChange },\n        this.state.items\n      )\n    );\n  }\n});\n\n_reactDom2[\"default\"].render(_react2[\"default\"].createElement(Test, null), document.getElementById('__react-content'));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./examples/simple.js\n ** module id = 178\n ** module chunks = 1\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _src = require('./src/');\n\nvar _src2 = _interopRequireDefault(_src);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nexports[\"default\"] = _src2[\"default\"]; // export this package's api\n\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 179\n ** module chunks = 1\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Picker = require('./Picker');\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_Picker)[\"default\"];\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 180\n ** module chunks = 1\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Animate = require('./Animate');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*\n * Based on Zynga Scroller (http://github.com/zynga/scroller)\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n */\n\nvar DECELERATION_VELOCITY_RATE = 0.95;\n// How much velocity is required to keep the deceleration running\nvar MIN_VELOCITY_TO_KEEP_DECELERATING = 0.5;\nvar POSITION_MAX_LENGTH = 40;\nvar MINIUM_TRACKING_FOR_SCROLL = 0;\nvar MINIUM_TRACKING_FOR_DRAG = 5;\nvar DEFAULT_ANIM_DURATION = 250;\nvar TIME_FRAME = 100;\n// How much velocity is required to start the deceleration\nvar MIN_VELOCITY_TO_START_DECELERATION = 4;\n\nfunction assign(to, from) {\n  for (var key in from) {\n    if (from.hasOwnProperty(key)) {\n      to[key] = from[key];\n    }\n  }\n}\n\nfunction getComputedStyle(el, key) {\n  var computedStyle = window.getComputedStyle(el);\n  return computedStyle[key] || '';\n}\n\nfunction isEmptyArray(a) {\n  return !a || !a.length;\n}\n\nfunction isChildrenEqual(c1, c2, pure) {\n  if (isEmptyArray(c1) && isEmptyArray(c2)) {\n    return true;\n  }\n  if (pure) {\n    return c1 === c2;\n  }\n  if (c1.length !== c2.length) {\n    return false;\n  }\n  var len = c1.length;\n  for (var i = 0; i < len; i++) {\n    if (c1[i].value !== c2[i].value || c1[i].label !== c2[i].label) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar Picker = _react2[\"default\"].createClass({\n  displayName: 'Picker',\n\n  propTypes: {\n    defaultSelectedValue: _react.PropTypes.any,\n    prefixCls: _react.PropTypes.string,\n    selectedValue: _react.PropTypes.any,\n    children: _react.PropTypes.array,\n    pure: _react.PropTypes.bool,\n    onValueChange: _react.PropTypes.func\n  },\n\n  getDefaultProps: function getDefaultProps() {\n    return {\n      prefixCls: 'rmc-picker',\n      pure: true,\n      onValueChange: function onValueChange() {}\n    };\n  },\n  getInitialState: function getInitialState() {\n    var selectedValueState = void 0;\n    var _props = this.props;\n    var selectedValue = _props.selectedValue;\n    var defaultSelectedValue = _props.defaultSelectedValue;\n    var children = _props.children;\n\n    if (selectedValue !== undefined) {\n      selectedValueState = selectedValue;\n    } else if (defaultSelectedValue !== undefined) {\n      selectedValueState = defaultSelectedValue;\n    } else if (children.length) {\n      selectedValueState = children[0].value;\n    }\n    return {\n      selectedValue: selectedValueState\n    };\n  },\n  componentDidMount: function componentDidMount() {\n    this.init();\n    var component = this.refs.component;\n\n    component.addEventListener('touchstart', this.onTouchStart, false);\n    component.addEventListener('touchmove', this.onTouchMove, false);\n    component.addEventListener('touchend', this.onTouchEnd, false);\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    if ('selectedValue' in nextProps) {\n      this.setState({\n        selectedValue: nextProps.selectedValue\n      });\n    }\n  },\n  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {\n    return this.state.selectedValue !== nextState.selectedValue || !isChildrenEqual(this.props.children, nextProps.children, this.props.pure);\n  },\n  componentDidUpdate: function componentDidUpdate(prevProps) {\n    if (!isChildrenEqual(prevProps.children, this.props.children, this.props.pure)) {\n      this.init();\n    } else {\n      this.select(this.state.selectedValue, false);\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    var component = this.refs.component;\n\n    component.removeEventListener('touchstart', this.onTouchStart, false);\n    component.removeEventListener('touchmove', this.onTouchMove, false);\n    component.removeEventListener('touchend', this.onTouchEnd, false);\n    this.clearAnim();\n  },\n  onTouchEnd: function onTouchEnd(e) {\n    this.doTouchEnd(+e.timeStamp);\n  },\n  onTouchMove: function onTouchMove(e) {\n    this.doTouchMove(e.touches, +e.timeStamp);\n  },\n  onTouchStart: function onTouchStart(e) {\n    if (e.target.tagName.match(/input|textarea|select/i)) {\n      return;\n    }\n    e.preventDefault();\n    this.doTouchStart(e.touches, +e.timeStamp);\n  },\n  setTop: function setTop(top) {\n    if (this.refs.content) {\n      this.refs.content.style.webkitTransform = 'translate3d(0, ' + -top + 'px, 0)';\n    }\n  },\n  setDimensions: function setDimensions(clientHeight, contentHeight) {\n    this.clientHeight = clientHeight;\n    this.contentHeight = contentHeight;\n\n    var totalItemCount = this.props.children.length;\n    var clientItemCount = Math.round(this.clientHeight / this.itemHeight);\n\n    this.minScrollTop = -this.itemHeight * (clientItemCount / 2);\n    this.maxScrollTop = this.minScrollTop + totalItemCount * this.itemHeight - 0.1;\n  },\n  clearAnim: function clearAnim() {\n    if (this.isDecelerating) {\n      _Animate.Animate.stop(this.isDecelerating);\n      this.isDecelerating = false;\n    }\n\n    if (this.isAnimating) {\n      _Animate.Animate.stop(this.isAnimating);\n      this.isAnimating = false;\n    }\n  },\n  init: function init() {\n    assign(this, {\n      isTracking: false,\n      didDecelerationComplete: false,\n      isDragging: false,\n      isDecelerating: false,\n      isAnimating: false,\n      clientHeight: 0,\n      contentHeight: 0,\n      itemHeight: 0,\n      scrollTop: 0,\n      minScrollTop: 0,\n      maxScrollTop: 0,\n      scheduledTop: 0,\n      lastTouchTop: 0,\n      lastTouchMove: 0,\n      positions: [],\n      minDecelerationScrollTop: 0,\n      maxDecelerationScrollTop: 0,\n      decelerationVelocityY: 0\n    });\n\n    var _refs = this.refs;\n    var indicator = _refs.indicator;\n    var component = _refs.component;\n    var content = _refs.content;\n\n\n    this.itemHeight = parseInt(getComputedStyle(indicator, 'height'), 10);\n\n    this.setDimensions(component.clientHeight, content.offsetHeight);\n\n    this.select(this.state.selectedValue, false);\n  },\n  selectByIndex: function selectByIndex(index, animate) {\n    if (index < 0 || index >= this.props.children.length) {\n      return;\n    }\n    this.scrollTop = this.minScrollTop + index * this.itemHeight;\n\n    this.scrollTo(this.scrollTop, animate);\n  },\n  select: function select(value, animate) {\n    var children = this.props.children;\n    for (var i = 0, len = children.length; i < len; i++) {\n      if (children[i].value === value) {\n        this.selectByIndex(i, animate);\n        return;\n      }\n    }\n    this.selectByIndex(0, animate);\n  },\n  scrollTo: function scrollTo(t, a) {\n    var top = t;\n    var animate = a;\n    animate = animate === undefined ? true : animate;\n\n    this.clearAnim();\n\n    top = Math.round(top / this.itemHeight) * this.itemHeight;\n    top = Math.max(Math.min(this.maxScrollTop, top), this.minScrollTop);\n\n    if (top === this.scrollTop || !animate) {\n      this.publish(top);\n      this.scrollingComplete();\n      return;\n    }\n    this.publish(top, DEFAULT_ANIM_DURATION);\n  },\n  fireValueChange: function fireValueChange(selectedValue) {\n    if (selectedValue !== this.state.selectedValue) {\n      if (!('selectedValue' in this.props)) {\n        this.setState({\n          selectedValue: selectedValue\n        });\n      }\n      this.props.onValueChange(selectedValue);\n    }\n  },\n  scrollingComplete: function scrollingComplete() {\n    var index = Math.round((this.scrollTop - this.minScrollTop - this.itemHeight / 2) / this.itemHeight);\n    var child = this.props.children[index];\n    if (child) {\n      this.fireValueChange(child.value);\n    }\n  },\n  doTouchStart: function doTouchStart(touches, timeStamp) {\n    this.clearAnim();\n    this.initialTouchTop = this.lastTouchTop = touches[0].pageY;\n    this.lastTouchMove = timeStamp;\n    this.enableScrollY = false;\n    this.isTracking = true;\n    this.didDecelerationComplete = false;\n    this.isDragging = false;\n    this.positions = [];\n  },\n  doTouchMove: function doTouchMove(touches, timeStamp) {\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!this.isTracking) {\n      return;\n    }\n\n    var currentTouchTop = touches[0].pageY;\n\n    var positions = this.positions;\n\n    // Are we already is dragging mode?\n    if (this.isDragging) {\n      var moveY = currentTouchTop - this.lastTouchTop;\n      var scrollTop = this.scrollTop;\n\n      if (this.enableScrollY) {\n        scrollTop -= moveY;\n\n        var minScrollTop = this.minScrollTop;\n        var maxScrollTop = this.maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < minScrollTop) {\n          // Slow down on the edges\n          if (scrollTop > maxScrollTop) {\n            scrollTop = maxScrollTop;\n          } else {\n            scrollTop = minScrollTop;\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > POSITION_MAX_LENGTH) {\n        positions.splice(0, POSITION_MAX_LENGTH / 2);\n      }\n\n      // Track scroll movement for declaration\n      positions.push(scrollTop, timeStamp);\n\n      // Sync scroll position\n      this.publish(scrollTop);\n      // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n        var distanceY = Math.abs(currentTouchTop - this.initialTouchTop);\n\n        this.enableScrollY = distanceY >= MINIUM_TRACKING_FOR_SCROLL;\n\n        positions.push(this.scrollTop, timeStamp);\n\n        this.isDragging = this.enableScrollY && distanceY >= MINIUM_TRACKING_FOR_DRAG;\n      }\n\n    // Update last touch positions and time stamp for next event\n    this.lastTouchTop = currentTouchTop;\n    this.lastTouchMove = timeStamp;\n  },\n  doTouchEnd: function doTouchEnd(timeStamp) {\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove')\n    // sits on the document and not on the element itself.\n    if (!this.isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    this.isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (this.isDragging) {\n      // Reset dragging flag\n      this.isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (timeStamp - this.lastTouchMove <= TIME_FRAME) {\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = this.positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (var i = endPos; i > 0 && positions[i] > this.lastTouchMove - TIME_FRAME; i -= 2) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedTop = this.scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          this.decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\n\n          // Verify that we have enough velocity to start deceleration\n          if (Math.abs(this.decelerationVelocityY) > MIN_VELOCITY_TO_START_DECELERATION) {\n            this.startDeceleration(timeStamp);\n          }\n        }\n      }\n    }\n\n    if (!this.isDecelerating) {\n      this.scrollTo(this.scrollTop);\n    }\n\n    // Fully cleanup list\n    this.positions.length = 0;\n  },\n\n\n  // Applies the scroll position to the content element\n  publish: function publish(top, animationDuration) {\n    var _this = this;\n\n    // Remember whether we had an animation,\n    // then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = this.isAnimating;\n    if (wasAnimating) {\n      _Animate.Animate.stop(wasAnimating);\n      this.isAnimating = false;\n    }\n\n    if (animationDuration) {\n      (function () {\n        // Keep scheduled positions for scrollBy functionality\n        _this.scheduledTop = top;\n\n        var oldTop = _this.scrollTop;\n        var diffTop = top - oldTop;\n\n        var step = function step(percent) {\n          _this.scrollTop = oldTop + diffTop * percent;\n          // Push values out\n          _this.setTop(_this.scrollTop);\n        };\n\n        var verify = function verify(id) {\n          return _this.isAnimating === id;\n        };\n\n        var completed = function completed(renderedFramesPerSecond, animationId, wasFinished) {\n          if (animationId === _this.isAnimating) {\n            _this.isAnimating = false;\n          }\n          if (_this.didDecelerationComplete || wasFinished) {\n            _this.scrollingComplete();\n          }\n        };\n\n        // When continuing based on previous animation\n        // we choose an ease-out animation instead of ease-in-out\n        _this.isAnimating = _Animate.Animate.start(step, verify, completed, animationDuration, wasAnimating ? _Animate.easeOutCubic : _Animate.easeInOutCubic);\n      })();\n    } else {\n      this.scheduledTop = this.scrollTop = top;\n      // Push values out\n      this.setTop(top);\n    }\n  },\n\n\n  // Called when a touch sequence end and the speed of\n  // the finger was high enough to switch into deceleration mode.\n  startDeceleration: function startDeceleration() {\n    var _this2 = this;\n\n    this.minDecelerationScrollTop = this.minScrollTop;\n    this.maxDecelerationScrollTop = this.maxScrollTop;\n\n    // Wrap class method\n    var step = function step(percent, now, render) {\n      _this2.stepThroughDeceleration(render);\n    };\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore,\n    // we stop the whole process here.\n    var verify = function verify() {\n      var shouldContinue = Math.abs(_this2.decelerationVelocityY) >= MIN_VELOCITY_TO_KEEP_DECELERATING;\n      if (!shouldContinue) {\n        _this2.didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function completed() {\n      _this2.isDecelerating = false;\n      if (_this2.scrollTop <= _this2.minScrollTop || _this2.scrollTop >= _this2.maxScrollTop) {\n        _this2.scrollTo(_this2.scrollTop);\n        return;\n      }\n      if (_this2.didDecelerationComplete) {\n        _this2.scrollingComplete();\n      }\n    };\n\n    // Start animation and switch on flag\n    this.isDecelerating = _Animate.Animate.start(step, verify, completed);\n  },\n\n\n  // Called on every step of the animation\n  stepThroughDeceleration: function stepThroughDeceleration() {\n    var scrollTop = this.scrollTop + this.decelerationVelocityY;\n\n    var scrollTopFixed = Math.max(Math.min(this.maxDecelerationScrollTop, scrollTop), this.minDecelerationScrollTop);\n    if (scrollTopFixed !== scrollTop) {\n      scrollTop = scrollTopFixed;\n      this.decelerationVelocityY = 0;\n    }\n\n    if (Math.abs(this.decelerationVelocityY) <= 1) {\n      if (Math.abs(scrollTop % this.itemHeight) < 1) {\n        this.decelerationVelocityY = 0;\n      }\n    } else {\n      this.decelerationVelocityY *= DECELERATION_VELOCITY_RATE;\n    }\n\n    this.publish(scrollTop);\n  },\n  render: function render() {\n    var _props2 = this.props;\n    var children = _props2.children;\n    var prefixCls = _props2.prefixCls;\n    var selectedValue = this.state.selectedValue;\n\n    var itemClassName = prefixCls + '-item';\n    var selectedItemClassName = itemClassName + ' ' + prefixCls + '-item-selected';\n    var items = children.map(function (item) {\n      return _react2[\"default\"].createElement(\n        'div',\n        {\n          className: selectedValue === item.value ? selectedItemClassName : itemClassName,\n          key: item.value,\n          'data-value': item.value\n        },\n        item.label\n      );\n    });\n    return _react2[\"default\"].createElement(\n      'div',\n      { className: '' + prefixCls, 'data-role': 'component', ref: 'component' },\n      _react2[\"default\"].createElement('div', { className: prefixCls + '-mask', 'data-role': 'mask' }),\n      _react2[\"default\"].createElement('div', { className: prefixCls + '-indicator', 'data-role': 'indicator', ref: 'indicator' }),\n      _react2[\"default\"].createElement(\n        'div',\n        { className: prefixCls + '-content', 'data-role': 'content', ref: 'content' },\n        items\n      )\n    );\n  }\n});\nexports[\"default\"] = Picker;\nmodule.exports = exports['default'];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Picker.jsx\n ** module id = 181\n ** module chunks = 1\n **/","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.easeOutCubic = easeOutCubic;\nexports.easeInOutCubic = easeInOutCubic;\nvar DESIRED_FRAMES = 60;\nvar MILLISECONDS_PER_SECOND = 1000;\nvar running = {};\nvar counter = 1;\n\nvar Animate = exports.Animate = {\n  // A requestAnimationFrame wrapper / polyfill.\n  requestAnimationFrame: function () {\n    var requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\n    return function (callback) {\n      requestFrame(callback);\n    };\n  }(),\n\n  // Stops the given animation.\n  stop: function stop(id) {\n    var cleared = running[id] !== null;\n    if (cleared) {\n      running[id] = null;\n    }\n    return cleared;\n  },\n\n\n  // Whether the given animation is still running.\n  isRunning: function isRunning(id) {\n    return running[id] !== null;\n  },\n\n\n  // Start the animation.\n  start: function start(stepCallback, verifyCallback, completedCallback, duration, easingMethod) {\n    var start = Date.now();\n    var lastFrame = start;\n    var percent = 0;\n    var dropCounter = 0;\n    var id = counter++;\n    // Compacting running db automatically every few new animations\n    if (id % 20 === 0) {\n      var newRunning = {};\n      for (var usedId in running) {\n        if (running.hasOwnProperty(usedId)) {\n          newRunning[usedId] = true;\n        }\n      }\n      running = newRunning;\n    }\n\n    // This is the internal step method which is called every few milliseconds\n    var step = function step(virtual) {\n      // Normalize virtual value\n      var render = virtual !== true;\n      // Get current time\n      var now = Date.now();\n\n      // Verification is executed before next animation step\n      if (!running[id] || verifyCallback && !verifyCallback(id)) {\n        running[id] = null;\n        if (completedCallback) {\n          completedCallback(DESIRED_FRAMES - dropCounter / ((now - start) / MILLISECONDS_PER_SECOND), id, false);\n        }\n        return;\n      }\n\n      // For the current rendering to apply let's update omitted steps in memory.\n      // This is important to bring internal state constiables up-to-date with progress in time.\n      if (render) {\n        var droppedFrames = Math.round((now - lastFrame) / (MILLISECONDS_PER_SECOND / DESIRED_FRAMES)) - 1;\n        for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n          step(true);\n          dropCounter++;\n        }\n      }\n\n      // Compute percent value\n      if (duration) {\n        percent = (now - start) / duration;\n        if (percent > 1) {\n          percent = 1;\n        }\n      }\n\n      // Execute step callback, then...\n      var value = easingMethod ? easingMethod(percent) : percent;\n      if ((stepCallback(value, now, render) === false || percent === 1) && render) {\n        running[id] = null;\n        if (completedCallback) {\n          completedCallback(DESIRED_FRAMES - dropCounter / ((now - start) / MILLISECONDS_PER_SECOND), id, percent === 1 || duration === null);\n        }\n      } else if (render) {\n        lastFrame = now;\n        Animate.requestAnimationFrame(step);\n      }\n    };\n\n    // Mark as running\n    running[id] = true;\n    // Init first step\n    Animate.requestAnimationFrame(step);\n    // Return unique animation ID\n    return id;\n  }\n};\n\n// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n// Open source under the BSD License.\nfunction easeOutCubic(pos) {\n  return Math.pow(pos - 1, 3) + 1;\n}\n\nfunction easeInOutCubic(p) {\n  var pos = p;\n  pos /= 0.5;\n  if (pos < 1) {\n    return 0.5 * Math.pow(pos, 3);\n  }\n  return 0.5 * (Math.pow(pos - 2, 3) + 2);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Animate.js\n ** module id = 182\n ** module chunks = 1\n **/"],"sourceRoot":""}